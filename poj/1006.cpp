/**********************************************************************
 * author:      banbao                                                *
 * language:    c++/c                                                 *
 * link:        http://poj.org/problem?id=1006                        *
 **********************************************************************/

/*
 * bbq:
 * 输入
 *      一行，包含四个整数：p, e, i和d，相邻两个整数之间用单个空格隔开
 *      p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算
 *      d 是给定的时间，可能小于p, e, 或 i。
 *      所有给定时间是非负的并且小于等于365, 所求的时间小于等于21252。
 * 输出
 *      一个整数，即从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。
 * 
 * 1. 全枚举, 每次 +1, 检验是否为 23/28/33 的倍数
 * 2. 优化枚举
*/

#include<stdio.h>

int main() {
    int p, e, i;
    /* p, e, i分别表示体力、情感和智力高峰出现的时间 ,体力、感情和智力周期，
       它们的周期长度为23天、28天和33天 */
    int d;//d 是给定的时间
    int n = 0;//n为输入第几组 
    int days = 0, test;

    while (1) {
        n++;
        scanf("%d %d %d %d", &p, &e, &i, &d);
        if (p == -1 && e == -1 && i == -1 && d == -1) break;

        else {
            for (days = 1; days <= 21252; days++) {
                test = d + days;
                if ((test - p) % 23 == 0)  break;
            }

            for (; days <= 21252; days += 23) {
                test = d + days;
                if ((test - e) % 28 == 0)  break;
            }

            for (; days <= 21252; days += 644) {
                test = d + days;
                if ((test - i) % 33 == 0)  break;
            }
        }
        printf("Case %d: the next triple peak occurs in %d days.\n", n, days);
    }
    return 0;
}

/*
    23*28=644
    23*28*33=21252
*/

/*
    0 0 0 0
    0 0 0 100
    5 20 34 325
    4 5 6 7
    283 102 23 320
    203 301 203 40
    -1 -1 -1 -1
*/
